import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const warpsRoot = path.resolve(__dirname, '../warps');

function findWarpFiles(dir) {
  const results = [];
  if (!fs.existsSync(dir)) return results;
  const list = fs.readdirSync(dir);
  list.forEach(file => {
    const filePath = path.resolve(dir, file);
    const stat = fs.statSync(filePath);
    if (stat && stat.isDirectory()) {
      results.push(...findWarpFiles(filePath));
    } else if (file === 'warp.json' || (file.endsWith('.json') && !file.includes('package'))) {
        // Only include if it looks like a warp (has protocol field)
        try {
            const content = JSON.parse(fs.readFileSync(filePath, 'utf8'));
            if (content.protocol && content.protocol.startsWith('warp:')) {
                results.push(filePath);
            }
        } catch (e) {}
    }
  });
  return results;
}

function inferType(value, key) {
  if (typeof value !== 'string') return 'any';

  if (value.startsWith('transform:')) {
    const code = value.replace('transform:', '');

    // Arrays (prioritize these to avoid matching inner string/number logic)
    if (code.includes('.map(') || code.includes('|| []')) {
        if (code.includes('.hash') || code.includes('.name') || code.includes('.address')) return 'string[]';
        return 'any[]';
    }

    // Booleans
    if (code.includes('|| false') || code.includes('|| true') || code.includes('===') || code.includes('!==') || code.includes('>') || code.includes('<')) {
         if (key.startsWith('IS_') || key.startsWith('HAS_') || code.includes('true') || code.includes('false')) {
             return 'boolean';
         }
    }

    // Numbers (explicit return types or math)
    if (code.includes('.length') || code.includes('.getTime()')) return 'number';
    if (code.includes('|| 0') || code.includes('Number(') || code.includes(' / ') || code.includes(' * ') || (code.includes(' + ') && !code.includes(' + \'') && !code.includes(' + "')) || code.includes(' - ')) {
        return 'number';
    }

    // Strings
    if (code.includes('.toFixed(') || code.includes('.toLocaleString(') || code.includes('`') || code.includes(' + \'') || code.includes(' + "') || code.includes('|| \'') || code.includes('|| "') || code.includes('BigInt(')) {
        return 'string';
    }
  }

  if (key.startsWith('IS_') || key.startsWith('HAS_')) return 'boolean';
  if (key.endsWith('_EGLD') || key.endsWith('_AMOUNT') || key.endsWith('_PRICE') || key.endsWith('_LIMIT') || key.endsWith('_USED') || key === 'NONCE' || key === 'TIMESTAMP' || key === 'ROUND' || key.endsWith('_COUNT')) return 'number';
  if (key.endsWith('_HASH') || key === 'STATUS' || key === 'SENDER' || key === 'RECEIVER' || key === 'DATA') return 'string';

  return 'any';
}

export function generateTypes() {
  const warpFiles = findWarpFiles(warpsRoot);
  warpFiles.forEach(warpFile => {
    const warp = JSON.parse(fs.readFileSync(warpFile, 'utf8'));
    if (!warp.output && !warp.actions) return;

    const dir = path.dirname(warpFile);
    if (path.basename(dir) === 'multiversx' && path.basename(warpFile) !== 'warp.json') {
        return;
    }

    const baseName = warp.name.replace(/[^a-zA-Z0-9]/g, '');
    const filePath = path.join(dir, 'warp.types.ts');

    if (fs.existsSync(filePath)) {
        const existingContent = fs.readFileSync(filePath, 'utf8');
        if (!existingContent.includes('auto-generated')) {
            console.log(`Skipping ${filePath} (manually maintained)`);
            return;
        }
    }

    let typeContent = `// This file is auto-generated by scripts/generate-warp-types.js\n\n`;

    // Generate Inputs type
    const inputs = {};
    if (warp.actions) {
        warp.actions.forEach(action => {
            if (action.inputs) {
                action.inputs.forEach(input => {
                    if (input.as) {
                        inputs[input.as] = input.type || 'string';
                    }
                });
            }
        });
    }

    typeContent += `export type ${baseName}Inputs = {\n`;
    Object.entries(inputs).forEach(([key, type]) => {
        const tsType = type === 'uint256' || type === 'int256' ? 'string' :
                       type === 'number' ? 'number' :
                       type === 'boolean' ? 'boolean' : 'string';
        typeContent += `  ${key}: ${tsType};\n`;
    });
    typeContent += `};\n\n`;

    // Generate Outputs type (previous logic)
    if (warp.output) {
        typeContent += `export type ${baseName}Data = {\n`;
        Object.entries(warp.output).forEach(([key, value]) => {
          const type = inferType(value, key);
          typeContent += `  ${key}: ${type};\n`;
        });
        typeContent += `};\n`;
    }

    fs.writeFileSync(filePath, typeContent);
    console.log(`Generated types for ${warp.name} in ${filePath}`);
  });
}

// Run if called directly
if (process.argv[1] === fileURLToPath(import.meta.url)) {
    generateTypes();
}
